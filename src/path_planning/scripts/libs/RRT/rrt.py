"""

Path planning Sample Code with Randomized Rapidly-Exploring Random Trees (RRT)

author: AtsushiSakai(@Atsushi_twi)

"""

import math
import random

import matplotlib.pyplot as plt
import matplotlib
import numpy as np

# Ray Casting
from libs.RayCasting.raycasting import point_in_polygon, Vector

show_animation = True

matplotlib.use('Agg')

class RRT:
    """
    Class for RRT planning
    """

    class Node:
        """
        RRT Node
        """

        def __init__(self, x, y):
            self.x = x
            self.y = y
            self.path_x = []
            self.path_y = []
            self.parent = None

    def __init__(self, start, goal, obstacle_list, rand_area,
                 expand_dis=3.0, path_resolution=0.5, goal_sample_rate=5, max_iter=500, check_collision_mode='circle'):
        """
        Setting Parameter

        start:Start Position [x,y]
        goal:Goal Position [x,y]
        obstacleList:
            if check_collision_mode == 'circle': obstacle Positions [[x,y,size],...]
            if check_collision_mode == 'ray_casting': obstacles areas [[CartesianPoint_1, CartesianPoint_2, ..., CartesianPoint_n], ...]

        randArea:Random Sampling Area [min,max]

        """
        print('Initiated RRT')
        self.start = self.Node(start[0], start[1])
        self.end = self.Node(goal[0], goal[1])
        self.min_rand = rand_area[0]
        self.max_rand = rand_area[1]
        self.expand_dis = expand_dis
        self.path_resolution = path_resolution
        self.goal_sample_rate = goal_sample_rate
        self.max_iter = max_iter
        self.check_collision_mode = check_collision_mode
        self.obstacle_list = obstacle_list
        self.node_list = []
        print('Finished initiating RRT')

    def planning(self, animation=True):
        """
        rrt path planning

        animation: flag for animation on or off
        """
        print('Started RRT planning')

        self.node_list = [self.start]
        for i in range(self.max_iter):
            # print(i)
            rnd_node = self.get_random_node()
            nearest_ind = self.get_nearest_node_index(self.node_list, rnd_node)
            nearest_node = self.node_list[nearest_ind]

            new_node = self.steer(nearest_node, rnd_node, self.expand_dis)

            if self.check_collision(new_node, self.obstacle_list):
                self.node_list.append(new_node)

            if animation and i % 5 == 0:
                self.draw_graph(rnd_node)

            if self.calc_dist_to_goal(self.node_list[-1].x, self.node_list[-1].y) <= self.expand_dis:
                final_node = self.steer(self.node_list[-1], self.end, self.expand_dis)
                if self.check_collision(final_node, self.obstacle_list):
                    return self.generate_final_course(len(self.node_list) - 1)

            if animation and i % 5:
                self.draw_graph(rnd_node)

            # break

        return None  # cannot find path

    def steer(self, from_node, to_node, extend_length=float("inf")):
    """
        Steer towards a target node from the current node.

        This method calculates a new node along the path from the current node (`from_node`) to the target node (`to_node`). The steering is limited by the `extend_length`, which is the maximum distance the new node can be from the current node.

        Parameters:
        - `from_node`: The current node from which steering begins.
        - `to_node`: The target node towards which steering is performed.
        - `extend_length` (optional): The maximum distance to extend the path from the current node (default: infinity).

        Returns:
        - `new_node`: The new node generated by steering towards the target node.

        The steering process involves calculating the distance and angle between the current node and the target node. The new node is then extended along this path, considering the specified `extend_length`. The resulting node is returned.

        Note: The path between the current node and the target node is discretized using the path resolution.

        """
        new_node = self.Node(from_node.x, from_node.y)
        d, theta = self.calc_distance_and_angle(new_node, to_node)

        new_node.path_x = [new_node.x]
        new_node.path_y = [new_node.y]

        if extend_length > d:
            extend_length = d

        n_expand = math.floor(extend_length / self.path_resolution)

        for _ in range(n_expand):
            new_node.x += self.path_resolution * math.cos(theta)
            new_node.y += self.path_resolution * math.sin(theta)
            new_node.path_x.append(new_node.x)
            new_node.path_y.append(new_node.y)

        d, _ = self.calc_distance_and_angle(new_node, to_node)
        if d <= self.path_resolution:
            new_node.path_x.append(to_node.x)
            new_node.path_y.append(to_node.y)

        new_node.parent = from_node

        return new_node

    def generate_final_course(self, goal_ind):
        """
        Generate the final course from the starting point to the goal node.

        This method traces back the path from the goal node to the starting point and generates a list of waypoints representing the final course.

        Parameters:
        - `goal_ind`: Index of the goal node in the node list.

        Returns:
        - `path`: A list of waypoints representing the final course from the starting point to the goal node.

        The method starts from the goal node (`goal_ind`) and traces back through the parent nodes until reaching the starting point. It appends the coordinates of each visited node to the `path` list.

        Note: The generated path includes both the starting point and the goal node.

        """
        path = [[self.end.x, self.end.y]]
        node = self.node_list[goal_ind]
        while node.parent is not None:
            path.append([node.x, node.y])
            node = node.parent
        path.append([node.x, node.y])

        return path

    def calc_dist_to_goal(self, x, y):
        """
        Calculate the Euclidean distance from a point (x, y) to the goal.

        Parameters:
        - `x`: X-coordinate of the point.
        - `y`: Y-coordinate of the point.

        Returns:
        - `distance`: Euclidean distance from the specified point to the goal.

        This method calculates the Euclidean distance between the specified point (x, y) and the goal node in the motion planning algorithm. It is commonly used to assess the proximity of a point to the goal during path planning.

        """
        dx = x - self.end.x
        dy = y - self.end.y
        return math.hypot(dx, dy)

    def get_random_node(self):
        """
        Generate a random node for exploration in the configuration space.

        Returns:
        - `rnd`: A randomly generated node within the configuration space.

        This method generates a random node for exploration in the configuration space during the RRT (Rapidly-exploring Random Tree) motion planning algorithm. The randomness can be biased based on the `goal_sample_rate` parameter.

        """
        if random.randint(0, 100) > self.goal_sample_rate:
            rnd = self.Node(random.uniform(self.min_rand, self.max_rand),
                            random.uniform(self.min_rand, self.max_rand))
        else:  # goal point sampling
            rnd = self.Node(self.end.x, self.end.y)
        return rnd

    def draw_graph(self, rnd=None):
        """
        Visualize the RRT graph, including nodes, edges, start, end, and obstacles.

        Parameters:
        - `rnd`: A randomly generated node for visualization (default: None).

        This method generates a visualization of the RRT (Rapidly-exploring Random Tree) graph, including nodes, edges, start and end positions, and obstacles. The graph is plotted using Matplotlib.

        """
        # plt.clf()
        # for stopping simulation with the esc key.
        # plt.gcf().canvas.mpl_connect('key_release_event', lambda event: [exit(0) if event.key == 'escape' else None])
        plt.Figure()
        if rnd is not None:
            plt.plot(rnd.x, rnd.y, "^k")
        for node in self.node_list:
            if node.parent:
                plt.plot(node.path_x, node.path_y, "-g")

        for (ox, oy, size) in self.obstacle_list:
            self.plot_circle(ox, oy, size)

        plt.plot(self.start.x, self.start.y, "xr")
        plt.plot(self.end.x, self.end.y, "xr")
        plt.axis("equal")
        # plt.axis([-502, 1618, -502, 1618]) # Mapa 0
        # plt.axis([241, 3356217, 241, 3356217]) # Mapa 1
        plt.axis('auto') # Mapa 1
        plt.grid(True)
        # plt.pause(0.01)
        # plt.ioff()
        plt.savefig('out_rrt.png')
        plt.close()

    @staticmethod
    def plot_circle(x, y, size, color="-b"):  # pragma: no cover
        """
        Plot a circular obstacle in the graph.

        Parameters:
        - `x`: x-coordinate of the center of the circle.
        - `y`: y-coordinate of the center of the circle.
        - `size`: radius of the circle.
        - `color`: color of the circle (default: "-b").

        This static method plots a circular obstacle in the RRT graph. It is typically used within the `draw_graph` method.

        """
        deg = list(range(0, 360, 5))
        deg.append(0)
        xl = [x + size * math.cos(np.deg2rad(d)) for d in deg]
        yl = [y + size * math.sin(np.deg2rad(d)) for d in deg]
        plt.plot(xl, yl, color)

    @staticmethod
    def get_nearest_node_index(node_list, rnd_node):
        """
        Get the index of the nearest node in a list to a given random node.

        Parameters:
        - `node_list`: List of nodes to search for the nearest node.
        - `rnd_node`: Random node for which the nearest node needs to be found.

        Returns:
        - Index of the nearest node in the `node_list`.

        This static method calculates the Euclidean distance between a random node (`rnd_node`) and each node in a given list (`node_list`). It returns the index of the node in `node_list` that is closest to the random node.

        """
        dlist = [(node.x - rnd_node.x) ** 2 + (node.y - rnd_node.y)
                 ** 2 for node in node_list]
        minind = dlist.index(min(dlist))

        return minind

    @staticmethod
    def check_collision_circle(node, obstacleList):
        """
            Check collision between a path generated by a node and a list of circular obstacles.

            Parameters:
            - `node`: Node containing the path information to check for collision.
            - `obstacleList`: List of circular obstacles represented as tuples (ox, oy, size).

            Returns:
            - `True` if the path is collision-free, `False` if a collision is detected.

            This static method checks for collision between the path generated by a given node and a list of circular obstacles. The circular obstacles are represented as tuples (ox, oy, size), where (ox, oy) is the center of the circle, and `size` is the radius.

            The method calculates the distance between each point on the path and the center of each circular obstacle. If any point is within the radius of an obstacle, a collision is detected, and the method returns `False`. Otherwise, if the entire path is collision-free, it returns `True`.

        """        
        # Original function

        if node is None:
            return False

        for (ox, oy, size) in obstacleList:
            dx_list = [ox - x for x in node.path_x]
            dy_list = [oy - y for y in node.path_y]
            d_list = [dx * dx + dy * dy for (dx, dy) in zip(dx_list, dy_list)]

            if min(d_list) <= size ** 2:
                return False  # collision

        return True  # safe

    @staticmethod
    def check_collision_raycasting(node, obstacleList):
        """
        Uses Ray Casting to check collision between a path generated by a node and a list of polygons.

        Parameters:
        - `node`: Node containing the path information to check for collision.
        - `obstacleList`: List of polygons represented as lists of vertices.

        Returns:
        - `True` if the path is collision-free, `False` if a collision is detected.

        This static method uses Ray Casting to check for collision between the path generated by a given node and a list of polygons. Each polygon is represented as a list of vertices (x, y).

        The method iterates through each point on the path and checks if it is inside any of the polygons. If a point is inside a polygon, a collision is detected, and the method returns `False`. Otherwise, if the entire path is collision-free, it returns `True`.

        Ray Casting is a technique that involves casting rays from a point and counting how many times they intersect with the edges of a polygon. If the number of intersections is odd, the point is inside the polygon.

        """
        if node is None:
            return False  # collision

        for x, y in zip(node.path_x, node.path_y):
            for obstacle in obstacleList:
                point = Vector(x, y)
                if point_in_polygon(point, obstacle):
                    return False  # collision

        return True  # safe


    def check_collision(self, node, obstacleList):
        """
        Checks collision between a path generated by a node and a list of obstacles based on the selected collision mode.

        Parameters:
        - `node`: Node containing the path information to check for collision.
        - `obstacleList`: List of obstacles to check for collision.

        Returns:
        - `True` if the path is collision-free, `False` if a collision is detected.

        This method checks for collision between the path generated by a given node and a list of obstacles based on the selected collision mode. The collision mode can be set to either 'circle' or 'ray_casting'.

        If the collision mode is set to 'circle', the method uses circular collision checking, and if it is set to 'ray_casting', the method uses Ray Casting for collision checking.

        Raises a `ValueError` if the collision mode is not set to a valid value.

        """
        if self.check_collision_mode == 'circle':
            return self.check_collision_circle(node, obstacleList)
        elif self.check_collision_mode == 'ray_casting':
            return self.check_collision_raycasting(node, obstacleList)
        raise ValueError(f'Must set check_collision_mode to one of the valid values: [circle, ray_casting]')

    @staticmethod
    def calc_distance_and_angle(from_node, to_node):
        """
        Calculate the distance and angle between two nodes.

        Parameters:
        - `from_node`: Starting node.
        - `to_node`: Destination node.

        Returns:
        - Tuple containing the distance and angle.

        This static method calculates the Euclidean distance and angle in radians between two nodes. It takes a starting node (`from_node`) and a destination node (`to_node`) as parameters.

        The method returns a tuple containing the distance and angle between the two nodes.

        """
        dx = to_node.x - from_node.x
        dy = to_node.y - from_node.y
        d = math.hypot(dx, dy)
        theta = math.atan2(dy, dx)
        return d, theta


def main(gx=6.0, gy=10.0):
    print("start " + __file__)

    # ====Search Path with RRT====
    obstacleList = [
        (5, 5, 1),
        (3, 6, 2),
        (3, 8, 2),
        (3, 10, 2),
        (7, 5, 2),
        (9, 5, 2),
        (8, 10, 1)
    ]  # [x, y, radius]
    # Set Initial parameters
    rrt = RRT(start=[0, 0],
              goal=[gx, gy],
              rand_area=[-2, 15],
              obstacle_list=obstacleList)
    path = rrt.planning(animation=show_animation)

    if path is None:
        print("Cannot find path")
    else:
        print("found path!!")

        # Draw final path
        if show_animation:
            rrt.draw_graph()
            plt.plot([x for (x, y) in path], [y for (x, y) in path], '-r')
            plt.grid(True)
            plt.pause(0.01)  # Need for Mac
            plt.show()


if __name__ == '__main__':
    main()
